import { useEffect, useMemo, useRef, useState } from "react";
import { invoke } from "@tauri-apps/api/core";
import { open, save } from "@tauri-apps/plugin-dialog";
import Editor from "@monaco-editor/react";
import "./App.css";

function registerLatexLanguage(monaco) {
    monaco.languages.register({ id: "latex" });
    monaco.languages.setMonarchTokensProvider("latex", {
        tokenizer: {
            root: [
                [/%.*$/, "comment"],
                [/\\[a-zA-Z@]+/, "keyword"],
                [/\{|\}/, "delimiter.bracket"],
                [/\$+/, "delimiter"],
                [/\\begin(?=\{)/, "keyword"],
                [/\\end(?=\{)/, "keyword"]
            ]
        }
    });
    monaco.languages.setLanguageConfiguration("latex", {
        comments: { lineComment: "%" },
        brackets: [
            ["{", "}"],
            ["[", "]"],
            ["(", ")"]
        ],
        autoClosingPairs: [
            { open: "{", close: "}" },
            { open: "[", close: "]" },
            { open: "(", close: ")" },
            { open: "$", close: "$" }
        ],
        surroundingPairs: [
            { open: "{", close: "}" },
            { open: "[", close: "]" },
            { open: "(", close: ")" },
            { open: "$", close: "$" }
        ]
    });
}

function registerLatexCompletions(monaco) {
    return monaco.languages.registerCompletionItemProvider("latex", {
        triggerCharacters: ["\\"],
        provideCompletionItems(model, position) {
            const word = model.getWordUntilPosition(position);
            const linePrefix = model.getLineContent(position.lineNumber);
            const backslashColumn =
                word.startColumn > 1 && linePrefix[word.startColumn - 2] === "\\" ? word.startColumn - 1 : word.startColumn;
            const range = {
                startLineNumber: position.lineNumber,
                startColumn: backslashColumn,
                endLineNumber: position.lineNumber,
                endColumn: word.endColumn
            };
            return {
                suggestions: [
                    {
                        label: "\\item",
                        kind: monaco.languages.CompletionItemKind.Keyword,
                        insertText: "\\item",
                        range
                    },
                    {
                        label: "\\begin{itemize}",
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        insertText: "\\begin{itemize}\n\\item ${1:item}\n\\end{itemize}",
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range
                    },
                    {
                        label: "\\begin{enumerate}",
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        insertText: "\\begin{enumerate}\n\\item ${1:item}\n\\end{enumerate}",
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range
                    },
                    {
                        label: "\\begin{equation}",
                        kind: monaco.languages.CompletionItemKind.Snippet,
                        insertText: "\\begin{equation}\n${1:equation}\n\\end{equation}",
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        range
                    }
                ]
            };
        }
    });
}

function App() {
    // ÈªòËÆ§ÁöÑ LaTeX Ê®°Áâà‰ª£Á†Å
    const [code, setCode] = useState(
        `\\documentclass{article}
\\usepackage{amsmath}
\\begin{document}
\\title{Hello Tauri + Tectonic}
\\author{Your Name}
\\maketitle

\\section{Introduction}
This is a \\textbf{PDF} generated by Tectonic via CLI!

\\section{Formula}
Einstein said:
$$ E = mc^2 $$

\\end{document}`
    );

    const [pdfUrl, setPdfUrl] = useState("");
    const [currentPath, setCurrentPath] = useState("");
    const [fileTree, setFileTree] = useState([]);
    const [rootPath, setRootPath] = useState("");
    const [expandedPaths, setExpandedPaths] = useState(new Set());
    const [loading, setLoading] = useState(false);
    const [pdfKey, setPdfKey] = useState(0);
    const [logs, setLogs] = useState("");
    const [isDirty, setIsDirty] = useState(false);
    const monacoRef = useRef(null);
    const editorRef = useRef(null);
    const completionRef = useRef(null);

    const [fetchedPaths, setFetchedPaths] = useState(new Set());
    const codeRef = useRef(code);
    const currentPathRef = useRef(currentPath);

    useEffect(() => { codeRef.current = code; }, [code]);
    useEffect(() => { currentPathRef.current = currentPath; }, [currentPath]);

    const normalizePath = (value) => value.replace(/\\\\/g, "/");

    // ËæÖÂä©ÂáΩÊï∞ÔºöÊèêÂèñÁà∂ÁõÆÂΩïË∑ØÂæÑ
    const getParentPath = (path) => {
        if (!path) return "";
        // ÁÆÄÂçïÂ§ÑÁêÜ Windows/Unix Ë∑ØÂæÑÂàÜÈöîÁ¨¶
        const normalized = path.replace(/\\/g, "/");
        return normalized.substring(0, normalized.lastIndexOf("/"));
    };

    // Êñ∞Â¢ûÔºöÂà∑Êñ∞ÊåáÂÆöÊñá‰ª∂Â§πÁöÑÂÜÖÂÆπ
    const refreshFolder = async (folderPath) => {
        if (!folderPath) return;
        try {
            const entries = await invoke("list_files", { rootPath: folderPath });
            // Â§çÁî®‰πãÂâçÁöÑÂêàÂπ∂ÈÄªËæë (ÂÅáËÆæ‰Ω†Â∑≤ÁªèÂ∫îÁî®‰∫Ü‰∏ä‰∏ÄËΩÆÁöÑ mergeFileEntries)
            setFileTree((prev) => {
                const map = new Map();
                prev.forEach(item => map.set(item.path, item));
                entries.forEach(item => map.set(item.path, item));
                return Array.from(map.values());
            });
            // Â¶ÇÊûúËøô‰∏™Êñá‰ª∂Â§πÊ≤°Âú® fetchedPaths ÈáåÔºà‰∏çÂ§™ÂèØËÉΩÔºâÔºåÂä†ËøõÂéª
            setFetchedPaths(prev => new Set(prev).add(normalizePath(folderPath)));
        } catch (e) {
            console.error("Refresh failed", e);
        }
    };

    async function handleCompile() {
        setLoading(true);
        setLogs("Compiling... (Check terminal for details)");
        if (monacoRef.current && editorRef.current) {
            const model = editorRef.current.getModel();
            if (model) {
                monacoRef.current.editor.setModelMarkers(model, "latex", []);
            }
        }
        try {
            const pdfBytes = await invoke("compile_latex", {
                latexCode: code,
                filePath: currentPath || null
            });

            const byteArray = new Uint8Array(pdfBytes);
            const blob = new Blob([byteArray], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);
            if (pdfUrl) URL.revokeObjectURL(pdfUrl);
            setPdfUrl(url);
            setPdfKey((prev) => prev + 1);

            if (currentPath) {
                const parentDir = getParentPath(currentPath);
                await refreshFolder(parentDir);
                setLogs("Success! PDF generated & Saved. File tree updated.");
            } else {
                setLogs("Success! PDF generated (Temp mode).");
            }

            setIsDirty(false);
        } catch (e) {
            console.error(e);
            const errors = Array.isArray(e) ? e : e?.error;
            if (Array.isArray(errors) && monacoRef.current && editorRef.current) {
                const model = editorRef.current.getModel();
                if (model) {
                    const lineRegex = /input\.tex:(\d+)/;
                    const markers = errors.map((err) => {
                        const message = err?.message || "Compilation error";
                        const match = message.match(lineRegex);
                        const parsedLine = match ? Number(match[1]) : Number(err?.line);
                        const line = Math.max(1, parsedLine || 1);
                        const maxColumn = model.getLineMaxColumn(line);
                        return {
                            severity: monacoRef.current.MarkerSeverity.Error,
                            message,
                            startLineNumber: line,
                            startColumn: 1,
                            endLineNumber: line,
                            endColumn: maxColumn
                        };
                    });
                    monacoRef.current.editor.setModelMarkers(model, "latex", markers);
                }
            }
            if (Array.isArray(errors)) {
                const details = errors
                    .map((err) => `L${err.line || 0}: ${err.message}`)
                    .join("\n");
                setLogs("Compile errors:\n" + details);
            } else {
                setLogs("Error: " + e);
            }
        } finally {
            setLoading(false);
        }
    }

    async function handleSaveAs() {
        const path = await save({
            filters: [{ name: "LaTeX", extensions: ["tex"] }]
        });

        if (!path) {
            setLogs("Save canceled.");
            return;
        }

        setLogs("Saving...");
        try {
            await invoke("save_file", { path, content: code });
            setCurrentPath(path);
            setIsDirty(false);
            setLogs(`Saved: ${path}`);
        } catch (e) {
            console.error(e);
            setLogs("Save failed: " + e);
            alert("‰øùÂ≠òÂá∫Èîô: " + e);
        }
    }

    async function handleSave() {
        if (!currentPath) {
            await handleSaveAs();
            return;
        }

        setLogs("Saving...");
        try {
            await invoke("save_file", { path: currentPath, content: code });
            setIsDirty(false);
            setLogs(`Saved: ${currentPath}`);
            await handleCompile();
        } catch (e) {
            console.error(e);
            setLogs("Save failed: " + e);
            alert("‰øùÂ≠òÂá∫Èîô: " + e);
        }
    }

    async function handleOpen() {
        const selected = await open({
            filters: [{ name: "LaTeX", extensions: ["tex"] }],
            multiple: false
        });

        if (!selected) {
            setLogs("Open canceled.");
            return;
        }

        const path = Array.isArray(selected) ? selected[0] : selected;
        setLogs("Opening...");
        try {
            const content = await invoke("read_file", { path });
            setCode(content);
            setCurrentPath(path);
            setIsDirty(false);
            setLogs(`Opened: ${path}`);
        } catch (e) {
            console.error(e);
            setLogs("Open failed: " + e);
            alert("ÊâìÂºÄÂá∫Èîô: " + e);
        }
    }

    async function handleOpenFolder() {
        const selected = await open({
            directory: true,
            multiple: false
        });

        if (!selected) {
            setLogs("Open folder canceled.");
            return;
        }

        const path = Array.isArray(selected) ? selected[0] : selected;
        setLogs("Loading folder...");
        try {
            const entries = await invoke("list_files", { rootPath: path });
            setFileTree(entries);
            setRootPath(path);
            setExpandedPaths(new Set([normalizePath(path)]));
            setLogs(`Loaded folder: ${path}`);
        } catch (e) {
            console.error(e);
            setLogs("Open folder failed: " + e);
            alert("ÊâìÂºÄÁõÆÂΩïÂá∫Èîô: " + e);
        }
    }

    const fileTreeRoot = useMemo(() => {
        if (!rootPath) {
            return null;
        }

        const normalizedRoot = normalizePath(rootPath);
        const nodeMap = new Map();

        fileTree.forEach((entry) => {
            const normalizedPath = normalizePath(entry.path);
            nodeMap.set(normalizedPath, {
                ...entry,
                normalizedPath,
                children: []
            });
        });

        const rootName = normalizedRoot.split("/").filter(Boolean).pop() || normalizedRoot;
        const rootNode = {
            name: rootName,
            path: rootPath,
            normalizedPath: normalizedRoot,
            is_dir: true,
            children: []
        };

        nodeMap.forEach((node) => {
            const parentPath = node.normalizedPath.substring(0, node.normalizedPath.lastIndexOf("/"));
            if (!parentPath || parentPath === normalizedRoot) {
                rootNode.children.push(node);
                return;
            }
            const parent = nodeMap.get(parentPath);
            if (parent) {
                parent.children.push(node);
            } else {
                rootNode.children.push(node);
            }
        });

        const sortNodes = (nodes) => {
            nodes.sort((a, b) => {
                if (a.is_dir !== b.is_dir) {
                    return a.is_dir ? -1 : 1;
                }
                return a.name.localeCompare(b.name);
            });
            nodes.forEach((node) => {
                if (node.children.length > 0) {
                    sortNodes(node.children);
                }
            });
        };

        sortNodes(rootNode.children);
        return rootNode;
    }, [fileTree, rootPath]);

    const mergeFileEntries = (newEntries) => {
        setFileTree((prev) => {
            // ÂàõÂª∫‰∏Ä‰∏™ Map ÂéªÈáçÔºå‰ª• path ‰∏∫ key
            const map = new Map();
            prev.forEach(item => map.set(item.path, item));
            newEntries.forEach(item => map.set(item.path, item));
            return Array.from(map.values());
        });
    };

    const handleToggleFolder = async (node) => {
        const { normalizedPath, path, is_dir } = node;

        if (!is_dir) return;

        setExpandedPaths((prev) => {
            const next = new Set(prev);
            if (next.has(normalizedPath)) {
                next.delete(normalizedPath);
            } else {
                next.add(normalizedPath);
            }
            return next;
        });

        if (!expandedPaths.has(normalizedPath) && !fetchedPaths.has(normalizedPath)) {
            setLogs(`Loading ${node.name}...`);
            try {
                const entries = await invoke("list_files", { rootPath: path });
                mergeFileEntries(entries);
                setFetchedPaths(prev => new Set(prev).add(normalizedPath));
                setLogs(`Loaded ${node.name}`);
            } catch (e) {
                console.error(e);
                setLogs("Load folder failed: " + e);
            }
        }
    };

    const handleFileClick = async (path) => {
        if (isDirty && currentPath) {
            await handleSave();
        }
        setLogs("Opening...");
        invoke("read_file", { path })
            .then((content) => {
                setCode(content);
                setCurrentPath(path);
                setIsDirty(false);
                setLogs(`Opened: ${path}`);
            })
            .catch((e) => {
                console.error(e);
                setLogs("Open failed: " + e);
                alert("ÊâìÂºÄÂá∫Èîô: " + e);
            });
    };

    const renderFileNode = (node, depth = 0) => {
        const isExpanded = expandedPaths.has(node.normalizedPath);
        const isSelected = normalizePath(currentPathRef.current) === node.normalizedPath;
        const paddingLeft = 8 + depth * 12;
        const background = normalizePath(currentPath) === node.normalizedPath ? "#dbeafe" : "transparent";

        return (
            <div key={node.normalizedPath}>
                <div
                    onClick={() => {
                        if (node.is_dir) {
                            handleToggleFolder(node);
                        } else {
                            handleFileClick(node.path);
                        }
                    }}
                    style={{
                        fontSize: "12px",
                        padding: "2px 4px",
                        paddingLeft,
                        color: node.is_dir ? "#333" : "#555",
                        cursor: node.is_dir ? "pointer" : "pointer",
                        background,
                        borderRadius: "4px"
                    }}
                >
                    {node.is_dir ? "üìÅ " : "üìÑ "}
                    {node.name}
                    {isSelected && isDirty ? " ‚Ä¢" : ""}
                </div>
                {node.is_dir && isExpanded && node.children.map((child) => renderFileNode(child, depth + 1))}
            </div>
        );
    };

    useEffect(() => {
        const isMac = navigator.platform.toUpperCase().includes("MAC");
        const handleKeydown = (event) => {
            const isSaveCombo = (isMac ? event.metaKey : event.ctrlKey) && event.key.toLowerCase() === "s";
            if (!isSaveCombo) {
                return;
            }
            event.preventDefault();

            const currentCode = codeRef.current;
            const currentP = currentPathRef.current;

            if (!currentP) {
                performSave(currentP, currentCode);
            } else {
                performSave(currentP, currentCode);
            }
        };

        const performSave = async (path, content) => {
            if (!path) {
                alert("Use 'Save As' to save the file first.");
                return;
            }

            setLogs("Saving...");
            try {
                await invoke("save_file", { path, content });
                setLogs(`Saved: ${path}`);
                await invoke("compile_latex", { latexCode: content });
            } catch (e) {
                console.error(e);
                setLogs("Save failed: " + e);
            }
        };

        window.addEventListener("keydown", handleKeydown);
        return () => window.removeEventListener("keydown", handleKeydown);
    }, []);

    return (
        <div style={{ display: "flex", height: "100vh", flexDirection: "column", fontFamily: "sans-serif" }}>
            {/* È°∂ÈÉ®Â∑•ÂÖ∑Ê†è */}
            <div style={{ padding: "10px", background: "#f0f0f0", borderBottom: "1px solid #ccc", display: "flex", alignItems: "center", gap: "10px" }}>
                <button
                    onClick={handleCompile}
                    disabled={loading}
                    style={{ padding: "8px 16px", cursor: loading ? "not-allowed" : "pointer", backgroundColor: "#007acc", color: "white", border: "none", borderRadius: "4px" }}
                >
                    {loading ? "Compiling..." : "‚ñ∂ Run Compile"}
                </button>
                <button
                    onClick={handleOpen}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#6b6b6b", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Open
                </button>
                <button
                    onClick={handleSave}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#1f6feb", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Save
                </button>
                <button
                    onClick={handleSaveAs}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#2d8f5a", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Save As
                </button>
                <button
                    onClick={handleOpenFolder}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#8a5a2b", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Open Folder
                </button>
                <span style={{ fontSize: "12px", color: loading ? "blue" : "#333" }}>{logs}</span>
            </div>

            {/* ‰∏ª‰ΩìÂå∫Âüü */}
            <div style={{ display: "flex", flex: 1, overflow: "hidden" }}>
                {/* Â∑¶‰æßÔºöÊñá‰ª∂Ê†ë */}
                <div style={{ width: "20%", borderRight: "1px solid #ddd", background: "#fafafa", padding: "8px", overflow: "auto" }}>
                    <div style={{ fontSize: "12px", fontWeight: "bold", marginBottom: "8px" }}>Files</div>
                    {fileTree.length === 0 ? (
                        <div style={{ fontSize: "12px", color: "#666" }}>No folder opened.</div>
                    ) : (
                        fileTreeRoot && renderFileNode(fileTreeRoot)
                    )}
                </div>
                {/* Â∑¶‰æßÔºöÁºñËæëÂô® */}
                <div style={{ width: "40%", borderRight: "1px solid #ddd" }}>
                    <Editor
                        height="100%"
                        language="latex"
                        theme="vs-dark"
                        value={code}
                        onChange={(value) => {
                            setCode(value || "");
                            setIsDirty(true);
                        }}
                        beforeMount={registerLatexLanguage}
                        onMount={(editor, monaco) => {
                            editorRef.current = editor;
                            monacoRef.current = monaco;
                            if (!completionRef.current) {
                                completionRef.current = registerLatexCompletions(monaco);
                            }
                            editor.onKeyDown((event) => {
                                if (event.keyCode !== monaco.KeyCode.Enter) {
                                    return;
                                }
                                const model = editor.getModel();
                                const position = editor.getPosition();
                                if (!model || !position) {
                                    return;
                                }
                                const lineContent = model.getLineContent(position.lineNumber);
                                const beforeCursor = lineContent.slice(0, position.column - 1);
                                const match = beforeCursor.match(/\\begin\{([^}]+)\}\s*$/);
                                if (!match) {
                                    return;
                                }
                                const envName = match[1];
                                event.preventDefault();
                                event.stopPropagation();
                                editor.executeEdits("latex-auto-end", [
                                    {
                                        range: new monaco.Range(
                                            position.lineNumber,
                                            position.column,
                                            position.lineNumber,
                                            position.column
                                        ),
                                        text: `\n\n\\end{${envName}}`
                                    }
                                ]);
                                editor.setPosition({
                                    lineNumber: position.lineNumber + 1,
                                    column: 1
                                });
                            });
                        }}
                        options={{
                            minimap: { enabled: false },
                            fontSize: 14,
                            wordWrap: "on"
                        }}
                    />
                </div>

                {/* Âè≥‰æßÔºöÈ¢ÑËßà */}
                <div style={{ width: "40%", background: "#555", display: "flex", alignItems: "center", justifyContent: "center" }}>
                    {pdfUrl ? (
                        <iframe
                            key={pdfKey}
                            src={pdfUrl}
                            width="100%"
                            height="100%"
                            style={{ border: "none" }}
                            title="PDF Preview"
                        />
                    ) : (
                        <div style={{ color: "#ccc" }}>Click "Run Compile" to generate PDF</div>
                    )}
                </div>
            </div>
        </div>
    );
}

export default App;
