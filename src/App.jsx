import { useEffect, useMemo, useRef, useState } from "react";
import { invoke } from "@tauri-apps/api/core";
import { open, save } from "@tauri-apps/plugin-dialog";
import Editor from "@monaco-editor/react";
import "./App.css";

function registerLatexLanguage(monaco) {
    monaco.languages.register({ id: "latex" });
    monaco.languages.setMonarchTokensProvider("latex", {
        tokenizer: {
            root: [
                [/%.*$/, "comment"],
                [/\\[a-zA-Z@]+/, "keyword"],
                [/\{|\}/, "delimiter.bracket"],
                [/\$+/, "delimiter"],
                [/\\begin(?=\{)/, "keyword"],
                [/\\end(?=\{)/, "keyword"]
            ]
        }
    });
    monaco.languages.setLanguageConfiguration("latex", {
        comments: { lineComment: "%" },
        brackets: [
            ["{", "}"],
            ["[", "]"],
            ["(", ")"]
        ],
        autoClosingPairs: [
            { open: "{", close: "}" },
            { open: "[", close: "]" },
            { open: "(", close: ")" },
            { open: "$", close: "$" }
        ],
        surroundingPairs: [
            { open: "{", close: "}" },
            { open: "[", close: "]" },
            { open: "(", close: ")" },
            { open: "$", close: "$" }
        ]
    });
}

function App() {
    // ÈªòËÆ§ÁöÑ LaTeX Ê®°Áâà‰ª£Á†Å
    const [code, setCode] = useState(
        `\\documentclass{article}
\\usepackage{amsmath}
\\begin{document}
\\title{Hello Tauri + Tectonic}
\\author{Your Name}
\\maketitle

\\section{Introduction}
This is a \\textbf{PDF} generated by Tectonic via CLI!

\\section{Formula}
Einstein said:
$$ E = mc^2 $$

\\end{document}`
    );

    const [pdfUrl, setPdfUrl] = useState("");
    const [currentPath, setCurrentPath] = useState("");
    const [fileTree, setFileTree] = useState([]);
    const [rootPath, setRootPath] = useState("");
    const [expandedPaths, setExpandedPaths] = useState(new Set());
    const [loading, setLoading] = useState(false);
    const [pdfKey, setPdfKey] = useState(0);
    const [logs, setLogs] = useState("");
    const [isDirty, setIsDirty] = useState(false);
    const monacoRef = useRef(null);
    const editorRef = useRef(null);

    const normalizePath = (value) => value.replace(/\\\\/g, "/");

    async function handleCompile() {
        setLoading(true);
        setLogs("Compiling... (Check terminal for details)");
        if (monacoRef.current && editorRef.current) {
            const model = editorRef.current.getModel();
            if (model) {
                monacoRef.current.editor.setModelMarkers(model, "latex", []);
            }
        }
        try {
            // Ë∞ÉÁî®Êàë‰ª¨Âú® Rust ÂêéÁ´ØÂÜôÁöÑ compile_latex ÂëΩ‰ª§
            const pdfBytes = await invoke("compile_latex", { latexCode: code });

            // Â∞ÜËøîÂõûÁöÑ‰∫åËøõÂà∂Êï∞ÊçÆËΩ¨Êç¢‰∏∫ÂèØ‰ª•Âú®ÊµèËßàÂô®ÊòæÁ§∫ÁöÑ URL
            const byteArray = new Uint8Array(pdfBytes);
            const blob = new Blob([byteArray], { type: "application/pdf" });
            const url = URL.createObjectURL(blob);

            if (pdfUrl) {
                URL.revokeObjectURL(pdfUrl);
            }
            setPdfUrl(url);
            setPdfKey((prev) => prev + 1);
            setLogs("Success! PDF generated.");
        } catch (e) {
            console.error(e);
            const errors = Array.isArray(e) ? e : e?.error;
            if (Array.isArray(errors) && monacoRef.current && editorRef.current) {
                const model = editorRef.current.getModel();
                if (model) {
                    const lineRegex = /input\.tex:(\d+)/;
                    const markers = errors.map((err) => {
                        const message = err?.message || "Compilation error";
                        const match = message.match(lineRegex);
                        const parsedLine = match ? Number(match[1]) : Number(err?.line);
                        const line = Math.max(1, parsedLine || 1);
                        const maxColumn = model.getLineMaxColumn(line);
                        return {
                            severity: monacoRef.current.MarkerSeverity.Error,
                            message,
                            startLineNumber: line,
                            startColumn: 1,
                            endLineNumber: line,
                            endColumn: maxColumn
                        };
                    });
                    monacoRef.current.editor.setModelMarkers(model, "latex", markers);
                }
            }
            if (Array.isArray(errors)) {
                const details = errors
                    .map((err) => `L${err.line || 0}: ${err.message}`)
                    .join("\n");
                setLogs("Compile errors:\n" + details);
            } else {
                setLogs("Error: " + e);
            }
        } finally {
            setLoading(false);
        }
    }

    async function handleSaveAs() {
        const path = await save({
            filters: [{ name: "LaTeX", extensions: ["tex"] }]
        });

        if (!path) {
            setLogs("Save canceled.");
            return;
        }

        setLogs("Saving...");
        try {
            await invoke("save_file", { path, content: code });
            setCurrentPath(path);
            setIsDirty(false);
            setLogs(`Saved: ${path}`);
        } catch (e) {
            console.error(e);
            setLogs("Save failed: " + e);
            alert("‰øùÂ≠òÂá∫Èîô: " + e);
        }
    }

    async function handleSave() {
        if (!currentPath) {
            await handleSaveAs();
            return;
        }

        setLogs("Saving...");
        try {
            await invoke("save_file", { path: currentPath, content: code });
            setIsDirty(false);
            setLogs(`Saved: ${currentPath}`);
            await handleCompile();
        } catch (e) {
            console.error(e);
            setLogs("Save failed: " + e);
            alert("‰øùÂ≠òÂá∫Èîô: " + e);
        }
    }

    async function handleOpen() {
        const selected = await open({
            filters: [{ name: "LaTeX", extensions: ["tex"] }],
            multiple: false
        });

        if (!selected) {
            setLogs("Open canceled.");
            return;
        }

        const path = Array.isArray(selected) ? selected[0] : selected;
        setLogs("Opening...");
        try {
            const content = await invoke("read_file", { path });
            setCode(content);
            setCurrentPath(path);
            setIsDirty(false);
            setLogs(`Opened: ${path}`);
        } catch (e) {
            console.error(e);
            setLogs("Open failed: " + e);
            alert("ÊâìÂºÄÂá∫Èîô: " + e);
        }
    }

    async function handleOpenFolder() {
        const selected = await open({
            directory: true,
            multiple: false
        });

        if (!selected) {
            setLogs("Open folder canceled.");
            return;
        }

        const path = Array.isArray(selected) ? selected[0] : selected;
        setLogs("Loading folder...");
        try {
            const entries = await invoke("list_files", { rootPath: path });
            setFileTree(entries);
            setRootPath(path);
            setExpandedPaths(new Set([normalizePath(path)]));
            setLogs(`Loaded folder: ${path}`);
        } catch (e) {
            console.error(e);
            setLogs("Open folder failed: " + e);
            alert("ÊâìÂºÄÁõÆÂΩïÂá∫Èîô: " + e);
        }
    }

    const fileTreeRoot = useMemo(() => {
        if (!rootPath) {
            return null;
        }

        const normalizedRoot = normalizePath(rootPath);
        const nodeMap = new Map();

        fileTree.forEach((entry) => {
            const normalizedPath = normalizePath(entry.path);
            nodeMap.set(normalizedPath, {
                ...entry,
                normalizedPath,
                children: []
            });
        });

        const rootName = normalizedRoot.split("/").filter(Boolean).pop() || normalizedRoot;
        const rootNode = {
            name: rootName,
            path: rootPath,
            normalizedPath: normalizedRoot,
            is_dir: true,
            children: []
        };

        nodeMap.forEach((node) => {
            const parentPath = node.normalizedPath.substring(0, node.normalizedPath.lastIndexOf("/"));
            if (!parentPath || parentPath === normalizedRoot) {
                rootNode.children.push(node);
                return;
            }
            const parent = nodeMap.get(parentPath);
            if (parent) {
                parent.children.push(node);
            } else {
                rootNode.children.push(node);
            }
        });

        const sortNodes = (nodes) => {
            nodes.sort((a, b) => {
                if (a.is_dir !== b.is_dir) {
                    return a.is_dir ? -1 : 1;
                }
                return a.name.localeCompare(b.name);
            });
            nodes.forEach((node) => {
                if (node.children.length > 0) {
                    sortNodes(node.children);
                }
            });
        };

        sortNodes(rootNode.children);
        return rootNode;
    }, [fileTree, rootPath]);

    const handleToggleFolder = (path) => {
        setExpandedPaths((prev) => {
            const next = new Set(prev);
            if (next.has(path)) {
                next.delete(path);
            } else {
                next.add(path);
            }
            return next;
        });
    };

    const handleFileClick = async (path) => {
        if (isDirty && currentPath) {
            await handleSave();
        }
        setLogs("Opening...");
        invoke("read_file", { path })
            .then((content) => {
                setCode(content);
                setCurrentPath(path);
                setIsDirty(false);
                setLogs(`Opened: ${path}`);
            })
            .catch((e) => {
                console.error(e);
                setLogs("Open failed: " + e);
                alert("ÊâìÂºÄÂá∫Èîô: " + e);
            });
    };

    const renderFileNode = (node, depth = 0) => {
        const isExpanded = expandedPaths.has(node.normalizedPath);
        const isSelected = normalizePath(currentPath) === node.normalizedPath;
        const paddingLeft = 8 + depth * 12;
        const background = isSelected ? "#dbeafe" : "transparent";

        return (
            <div key={node.normalizedPath}>
                <div
                    onClick={() => {
                        if (node.is_dir) {
                            handleToggleFolder(node.normalizedPath);
                        } else {
                            handleFileClick(node.path);
                        }
                    }}
                    style={{
                        fontSize: "12px",
                        padding: "2px 4px",
                        paddingLeft,
                        color: node.is_dir ? "#333" : "#555",
                        cursor: node.is_dir ? "pointer" : "pointer",
                        background,
                        borderRadius: "4px"
                    }}
                >
                    {node.is_dir ? "üìÅ " : "üìÑ "}
                    {node.name}
                    {isSelected && isDirty ? " ‚Ä¢" : ""}
                </div>
                {node.is_dir && isExpanded && node.children.map((child) => renderFileNode(child, depth + 1))}
            </div>
        );
    };

    useEffect(() => {
        const isMac = navigator.platform.toUpperCase().includes("MAC");
        const handleKeydown = (event) => {
            const isSaveCombo = (isMac ? event.metaKey : event.ctrlKey) && event.key.toLowerCase() === "s";
            if (!isSaveCombo) {
                return;
            }
            event.preventDefault();
            handleSave();
        };

        window.addEventListener("keydown", handleKeydown);
        return () => window.removeEventListener("keydown", handleKeydown);
    }, [code, currentPath]);

    return (
        <div style={{ display: "flex", height: "100vh", flexDirection: "column", fontFamily: "sans-serif" }}>
            {/* È°∂ÈÉ®Â∑•ÂÖ∑Ê†è */}
            <div style={{ padding: "10px", background: "#f0f0f0", borderBottom: "1px solid #ccc", display: "flex", alignItems: "center", gap: "10px" }}>
                <button
                    onClick={handleCompile}
                    disabled={loading}
                    style={{ padding: "8px 16px", cursor: loading ? "not-allowed" : "pointer", backgroundColor: "#007acc", color: "white", border: "none", borderRadius: "4px" }}
                >
                    {loading ? "Compiling..." : "‚ñ∂ Run Compile"}
                </button>
                <button
                    onClick={handleOpen}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#6b6b6b", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Open
                </button>
                <button
                    onClick={handleSave}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#1f6feb", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Save
                </button>
                <button
                    onClick={handleSaveAs}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#2d8f5a", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Save As
                </button>
                <button
                    onClick={handleOpenFolder}
                    style={{ padding: "8px 16px", cursor: "pointer", backgroundColor: "#8a5a2b", color: "white", border: "none", borderRadius: "4px" }}
                >
                    Open Folder
                </button>
                <span style={{ fontSize: "12px", color: loading ? "blue" : "#333" }}>{logs}</span>
            </div>

            {/* ‰∏ª‰ΩìÂå∫Âüü */}
            <div style={{ display: "flex", flex: 1, overflow: "hidden" }}>
                {/* Â∑¶‰æßÔºöÊñá‰ª∂Ê†ë */}
                <div style={{ width: "20%", borderRight: "1px solid #ddd", background: "#fafafa", padding: "8px", overflow: "auto" }}>
                    <div style={{ fontSize: "12px", fontWeight: "bold", marginBottom: "8px" }}>Files</div>
                    {fileTree.length === 0 ? (
                        <div style={{ fontSize: "12px", color: "#666" }}>No folder opened.</div>
                    ) : (
                        fileTreeRoot && renderFileNode(fileTreeRoot)
                    )}
                </div>
                {/* Â∑¶‰æßÔºöÁºñËæëÂô® */}
                <div style={{ width: "40%", borderRight: "1px solid #ddd" }}>
                    <Editor
                        height="100%"
                        language="latex"
                        theme="vs-dark"
                        value={code}
                        onChange={(value) => {
                            setCode(value || "");
                            setIsDirty(true);
                        }}
                        beforeMount={registerLatexLanguage}
                        onMount={(editor, monaco) => {
                            editorRef.current = editor;
                            monacoRef.current = monaco;
                        }}
                        options={{
                            minimap: { enabled: false },
                            fontSize: 14,
                            wordWrap: "on"
                        }}
                    />
                </div>

                {/* Âè≥‰æßÔºöÈ¢ÑËßà */}
                <div style={{ width: "40%", background: "#555", display: "flex", alignItems: "center", justifyContent: "center" }}>
                    {pdfUrl ? (
                        <iframe
                            key={pdfKey}
                            src={pdfUrl}
                            width="100%"
                            height="100%"
                            style={{ border: "none" }}
                            title="PDF Preview"
                        />
                    ) : (
                        <div style={{ color: "#ccc" }}>Click "Run Compile" to generate PDF</div>
                    )}
                </div>
            </div>
        </div>
    );
}

export default App;
